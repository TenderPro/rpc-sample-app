# application project makefile

SHELL          = /bin/bash
CFG           ?= .env
PRG           ?= $(shell basename $$PWD)

# -----------------------------------------------------------------------------
# Build config

GO            ?= go
SOURCES       ?= pkg/*/*.go *.go
VERSION       ?= $(shell git describe --tags --always)

# -----------------------------------------------------------------------------
# Runtime data

APP_PORT      ?= 7070

PGHOST        ?= localhost
PGPORT        ?= 5432
PGDATABASE    ?= $(PRG)
PGUSER        ?= $(PRG)
PGPASSWORD    ?= $(shell < /dev/urandom tr -dc A-Za-z0-9 | head -c14; echo)
PGAPPNAME     ?= $(PRG)

# -----------------------------------------------------------------------------
# docker part

APP_IMAGE    ?= $(PRG)

# image prefix
PROJECT_NAME ?= $(PRG)

# Service container network
DOCKER_NET   ?= dcape_net

# Postgresql container name
PG_CONTAINER ?= dcape_db_1

# -----------------------------------------------------------------------------
# docker-compose part

# dc image version
DC_VER       ?= 1.23.2

# App targets for dc
APPS         ?= app

# Service targets for dc
SERVICEAPPS  ?= log trace


define CONFIG_DEFAULT
# ------------------------------------------------------------------------------
# application config file, generated by make $(CFG)

# App/Docker listen addr
APP_PORT=$(APP_PORT)

# Docker image tag
APP_IMAGE=$(APP_IMAGE)

# Database

# Host
PGHOST=$(PGHOST)
# Port
PGPORT=$(PGPORT)
# Name
PGDATABASE=$(PGDATABASE)
# User
PGUSER=$(PGUSER)
# Password
PGPASSWORD=$(PGPASSWORD)
# App name
PGAPPNAME=$(PGAPPNAME)

endef
export CONFIG_DEFAULT

# ------------------------------------------------------------------------------

-include $(CFG)
export

.PHONY: all api dep build run lint test up up-db down psql clean help

all: help

gen:
	docker run -ti --rm \
  -w $$PWD \
  -v $$PWD:$$PWD \
  -v $$PWD/../rpckit:/usr/local/include/github.com/TenderPro/rpckit \
  tenderpro/protoc-go -I=. \
    --gogofast_out=plugins=grpc,\
Mgoogle/protobuf/timestamp.proto=github.com/gogo/protobuf/types,\
Mgoogle/protobuf/empty.proto=github.com/gogo/protobuf/types:\
pkg/pb/ \
    --grpc-gateway_out=logtostderr=true:pkg/pb \
    --govalidators_out="lang=go:pkg/pb" \
    --swagger_out=logtostderr=true,allow_merge=true,merge_file_name=api:static/html/devel/openapi/ \
    --wsdl_out=soapgen:pkg/soapgen \
    --grpcer_out=soapgen:pkg/soapgen \
    --doc_out=static/html/devel \
    --doc_opt=html,api.html \
    main.proto
	sed -i.bak 's|pb "."|pb "SELF/pkg/pb"|' pkg/soapgen/main.grpcer.go
	cat pkg/soapgen/main.wsdl > static/html/devel/api.wsdl 
	rm -f pkg/soapgen/main.wsdl
	if [ -f pkg/nrpcgen/main.nrpc.go ] ; then gofmt pkg/nrpcgen/main.nrpc.go > pkg/nrpcgen/main.nrpc.go.orig && rm -f pkg/nrpcgen/main.nrpc.go ; fi

#	rm -f static/html/devel/api.wsdl

# TODO:
#     --nrpc_out=plugins=prometheus:pkg/nrpcgen \


gen-prod: gen ## Generate files for production
	go-bindata -pkg static -prefix $PWD/static -o pkg/static/bindata.go static/...

gen-dev: ## Generate files for development
	go-bindata -debug -pkg staticgen -prefix static -o pkg/staticgen/bindata.go static/...
	# TODO: mocks


dep: ## Get the dependencies
	@go mod download

build: dep gen gen-dev ## Build the binary file for server
	@go build -i -v -tags dev .

run: ## Build and run binary
	@go run -tags dev . -- mono --debug

# --db.addr=localhost:5432 --addr=localhost:${APP_PORT} \
#	--db.name=${PGDATABASE} --db.user=${PGUSER} --db.password=${PGPASSWORD}

lint: ## Run linter
	@golangci-lint run

test: ## Run grpc client tests
	APP_ADDR=localhost:${APP_PORT} \
	go test -v -count=1 .

t-ping:
	curl -X POST http://localhost:8081/v1/sample/ping

t-stream:
	curl http://localhost:8081/v1/sample/ping/list/string88

t-time:
	curl http://localhost:8081/v1/time/5

## Run tests and fill coverage.out
cov: coverage.out

# internal target
coverage.out: $(SOURCES)
	$(GO) test -test.v -test.race -coverprofile=$@ -covermode=atomic -tags test ./...

## Open coverage report in browser
cov-html: cov
	$(GO) tool cover -html=coverage.out

## Clean coverage report
cov-clean:
	rm -f coverage.*

# ------------------------------------------------------------------------------
# Docker

up: ## Start pg and app containers
up: CMD=up -d
up: dc

up-db: ## Start pg container only
up-db: CMD=up -d db
up-db: dc

down: ## Stop containers and remove them
down: CMD=rm -f -s
down: dc

# $$PWD используется для того, чтобы текущий каталог был доступен 
# в контейнере docker-compose по тому же пути
# и относительные тома новых контейнеров могли его использовать
dc: docker-compose.yml ## Run docker-compose (make dc CMD=build)
	@docker run --rm  \
	  -v /var/run/docker.sock:/var/run/docker.sock \
	  -v $$PWD:$$PWD \
	  -w $$PWD \
	  docker/compose:$(DC_VER) \
	  -p $$PROJECT_NAME \
	  $(CMD)

# ------------------------------------------------------------------------------
# DB operations with docker and [dcape](https://github.com/dopos/dcape)

# (internal) Wait for postgresql container start
docker-wait:
	@echo -n "Checking PG is ready..."
	@until [[ `docker inspect -f "{{.State.Health.Status}}" $$DCAPE_DB` == healthy ]] ; do sleep 1 ; echo -n "." ; done
	@echo "Ok"

dcape-db-create: docker-wait ## Create user, db and load dump
	@echo "*** $@ ***" ; \
	docker exec -i $$DCAPE_DB psql -U postgres -c "CREATE USER \"$$PGUSER\" WITH PASSWORD '$$PGPASSWORD';" || true ; \
	docker exec -i $$DCAPE_DB psql -U postgres -c "CREATE DATABASE \"$$PGDATABASE\" OWNER \"$$PGUSER\";" || db_exists=1 ; \
	if [[ ! "$$db_exists" ]] ; then \
	    cat sql/crebas.sql | docker exec -i $$DCAPE_DB psql -U postgres -d $$PGDATABASE -1 -X ; \
	    echo "Restore completed" ; \
	fi

dcape-db-drop: docker-wait ## Drop database and user
	@echo "*** $@ ***"
	@docker exec -it $$DCAPE_DB psql -U postgres -c "DROP DATABASE \"$$PGDATABASE\";" || true
	@docker exec -it $$DCAPE_DB psql -U postgres -c "DROP USER \"$$PGUSER\";" || true

dcape-psql: docker-wait ## Run psql
	@docker exec -it $$DCAPE_DB psql -U $$PGUSER -d $$PGDATABASE

dcape-start: dcape-db-create up

dcape-start-hook: dcape-db-create reup

dcape-stop: down

# ------------------------------------------------------------------------------

psql: ## Run psql via postgresql docker container
	@docker exec -it $${PROJECT_NAME}_db_1 psql -U $$PGUSER -d $$PGDATABASE

$(CFG):
	@[ -f $@ ] || { echo "$$CONFIG_DEFAULT" > $@ ; echo "Warning: Created default $@" ; }

conf: ## Create initial config
	@true

clean: ## Remove previous builds
	@rm -f $(PRG)

help: ## Display this help screen
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' Makefile | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
